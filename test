import subprocess
import os
import re
import argparse

def decompile_apk(jadx_path, apk_path, output_dir="decompiled"):
    """
    Decompile APK using JADX.
    """
    print("Starting decompilation...")
    try:
        subprocess.run([jadx_path, "-d", output_dir, apk_path], check=True)
        print(f"Decompilation completed: {output_dir}")
    except subprocess.CalledProcessError as e:
        print(f"Decompilation failed: {e}")
        exit(1)
    return output_dir

def scan_for_websockets(decompiled_path):
    """
    Scan the decompiled source code for any WebSocket usage.
    """
    # Search patterns for WebSockets.
    websocket_patterns = [
        r"import\s+.*WebSocket;",  # Look for WebSocket imports.
        r"OkHttpClient\(\)\.newWebSocket",  # OkHttp WebSocket creation.
        r"new\s+WebSocketListener",  # WebSocketListener instances.
        r"ws://",  # Plain WebSocket protocol.
        r"wss://"  # Secure WebSocket protocol.
    ]
    findings = []

    for root, _, files in os.walk(decompiled_path):
        for file in files:
            if file.endswith(".java") or file.endswith(".kt"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    for pattern in websocket_patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            findings.append(file_path)
                            break  # Found WebSocket usage, move to next file.

    return findings

def report_findings(findings):
    """
    Print out the files where WebSocket usage was found.
    """
    if findings:
        print("\033[92mWebSocket usage found in the following files:\033[0m")
        for file in findings:
            print(f"- {file}")
    else:
        print("No WebSocket usage found.")

def parse_arguments():
    """
    Parse command-line arguments to allow flexibility in usage.
    """
    parser = argparse.ArgumentParser(description='Find WebSockets in APK files.')
    parser.add_argument('--jadx_path', type=str, help='Path to JADX binary', default="")
    parser.add_argument('--apk_path', type=str, help='Path to the APK file', default="")
    parser.add_argument('--decompiled_path', type=str, help='Path to already decompiled code', default="")
    return parser.parse_args()

def main():
    args = parse_arguments()

    if args.decompiled_path:
        # If a path to decompiled code is provided, use it directly.
        print("Using existing decompiled code.")
        decompiled_path = args.decompiled_path
    else:
        # Ensure necessary details are provided for decompilation.
        if not args.jadx_path or not args.apk_path:
            print("Missing jadx_path or apk_path. Exiting.")
            exit(1)
        decompiled_path = decompile_apk(args.jadx_path, args.apk_path)

    findings = scan_for_websockets(decompiled_path)
    report_findings(findings)

if __name__ == "__main__":
    main()
